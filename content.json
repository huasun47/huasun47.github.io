{"posts":[{"title":"剪贴板操作 Clipboard API","text":"介绍一共有三种方法可以实现剪贴板操作 Document.execCommand()方法 异步的 Clipboard API copy 事件和 paste 事件 Document.execCommand()Document.execCommand() 是操作剪贴板的传统方法，各种浏览器都支持，支持复制、剪切和粘贴这三个操作。 document.execCommand(‘copy’)（复制） document.execCommand(‘cut’)（剪切） document.execCommand(‘paste’)（粘贴） 复制： 复制时，先选中文本，然后调用 document.execCommand('copy')，选中的文本就会进入剪贴板 123const inputElement = document.querySelector(&quot;#input&quot;);inputElement.select();document.execCommand(&quot;copy&quot;); 粘贴粘贴时，调用document.execCommand('paste')，就会将剪贴板里面的内容，输出到当前的焦点元素中 123const pasteText = document.querySelector(&quot;#output&quot;);pasteText.focus();document.execCommand(&quot;paste&quot;); 缺点： 首先，它只能将选中的内容复制到剪贴板，无法向剪贴板任意写入内容。 其次，它是同步操作，如果复制/粘贴大量数据，页面会出现卡顿。有些浏览器还会跳出提示框，要求用户许可，这时在用户做出选择前，页面会失去响应 为了解决这些问题，还是使用 Clipboard API 异步 Clipboard API比传统的document.execCommand()方法更强大、更合理。 它的所有操作都是异步的，返回 Promise 对象，不会造成页面卡顿。而且，它可以将任意内容（比如图片）放入剪贴板。 navigator.clipboard 属性返回 Clipboard 对象，所有操作都通过这个对象进行 12// 如果navigator.clipboard属性返回undefined，就说明当前浏览器，不支持这个 APIconst clipboardObj = navigator.clipboard; 由于用户可能把敏感数据（比如密码）放在剪贴板，允许脚本任意读取会产生安全风险，所以这个 API 的安全限制比较多。 首先，Chrome 浏览器规定，只有 HTTPS 协议的页面才能使用这个 API。【开发环境 localhost 也可以】 其次，调用时需要明确获得用户的许可。权限的具体实现使用了 Permissions API，跟剪贴板相关的有两个权限：clipboard-write（写权限）和clipboard-read（读权限）。”写权限”自动授予脚本，而”读权限”必须用户明确同意给予。也就是说，写入剪贴板，脚本可以自动完成，但是读取剪贴板时，浏览器会弹出一个对话框，询问用户是否同意读取。 Clipboard 对象Clipboard 对象提供了四个方法，用来读写剪贴板。它们都是异步方法，返回 Promise 对象 Clipboard.readText() 用于复制剪贴板里面的文本数据 12345678document.body.addEventListener(&quot;click&quot;, async (e) =&gt; { try { const text = await navigator.clipboard.readText(); console.log(text); } catch { console.log(&quot;用户拒绝读取&quot;); }}); Clipboard.read() 用于复制剪贴板里面的数据，可以是文本数据，也可以是二进制数据（比如图片）。该方法需要用户明确给予许可。 该方法返回一个 Promise 对象。一旦该对象的状态变为 resolved，就可以获得一个数组，每个数组成员都是 ClipboardItem 对象的实例。 12345678910111213async function getClipboardContents() { try { const clipboardItems = await navigator.clipboard.read(); for (const clipboardItem of clipboardItems) { for (const type of clipboardItem.types) { const blob = await clipboardItem.getType(type); console.log(URL.createObjectURL(blob)); } } } catch (err) { console.error(err.name, err.message); }} ClipboardItem 对象表示一个单独的剪贴项，每个剪贴项都拥有 ClipboardItem.types 属性和 ClipboardItem.getType()方法。 ClipboardItem.types 属性返回一个数组，里面的成员是该剪贴项可用的 MIME 类型，比如某个剪贴项可以用 HTML 格式粘贴，也可以用纯文本格式粘贴，那么它就有两个 MIME 类型（text/html 和 text/plain）。 ClipboardItem.getType(type)方法用于读取剪贴项的数据，返回一个 Promise 对象。该方法接受剪贴项的 MIME 类型作为参数，返回该类型的数据，该参数是必需的，否则会报错。 Clipboard.writeText() 方法用于将文本内容写入剪贴板 123document.body.addEventListener(&quot;click&quot;, async (e) =&gt; { await navigator.clipboard.writeText(&quot;Yo&quot;);}); Clipboard.write() 方法用于将任意数据写入剪贴板，可以是文本数据，也可以是二进制数据。 该方法接受一个 ClipboardItem 实例作为参数，表示写入剪贴板的数据 12345678910111213try { const imgURL = &quot;https://dummyimage.com/300.png&quot;; const data = await fetch(imgURL); const blob = await data.blob(); await navigator.clipboard.write([ new ClipboardItem({ [blob.type]: blob, }), ]); console.log(&quot;Image copied.&quot;);} catch (err) { console.error(err.name, err.message);} copy 事件，cut 事件用户向剪贴板放入数据时，将触发 copy 事件 1234567const source = document.querySelector(&quot;.source&quot;);source.addEventListener(&quot;copy&quot;, (event) =&gt; { const selection = document.getSelection(); event.clipboardData.setData(&quot;text/plain&quot;, selection.toString().toUpperCase()); event.preventDefault();}); 事件对象的 clipboardData 属性包含了剪贴板数据。它是一个对象，有以下属性和方法 Event.clipboardData.setData(type, data)：修改剪贴板数据，需要指定数据类型。 Event.clipboardData.getData(type)：获取剪贴板数据，需要指定数据类型。 Event.clipboardData.clearData([type])：清除剪贴板数据，可以指定数据类型。如果不指定类型，将清除所有类型的数据。 Event.clipboardData.items：一个类似数组的对象，包含了所有剪贴项，不过通常只有一个剪贴项。 下面是拦截用户复制 👇 12345678910111213141516171819202122const clipboardItems = [];document.addEventListener(&quot;copy&quot;, async (e) =&gt; { e.preventDefault(); try { let clipboardItems = []; for (const item of e.clipboardData.items) { if (!item.type.startsWith(&quot;image/&quot;)) { continue; } clipboardItems.push( new ClipboardItem({ [item.type]: item, }) ); await navigator.clipboard.write(clipboardItems); console.log(&quot;Image copied.&quot;); } } catch (err) { console.error(err.name, err.message); }}); paste 事件用户使用剪贴板数据，进行粘贴操作时，会触发 paste 事件。 12345document.addEventListener(&quot;paste&quot;, async (e) =&gt; { e.preventDefault(); const text = await navigator.clipboard.readText(); console.log(&quot;Pasted text: &quot;, text);});","link":"/2022/06/04/%E6%95%99%E7%A8%8B/Clipboard%20API%E6%95%99%E7%A8%8B/"},{"title":"JavaScript 侦测手机浏览器的五种方法","text":"侦测方法navigator.userAgentJS 通过 navigator.userAgent 属性拿到这个字符串，只要里面包含 mobi、android、iphone 等关键字，就可以认定是移动设备。 123456789101112if (/Mobi|Android|iPhone/i.test(navigator.userAgent)) { // 当前设备是移动设备}// 另一种写法if ( navigator.userAgent.match(/Mobi/i) || navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/iPhone/i)) { // 当前设备是移动设备} 缺点: 不可靠，因为用户可以修改这个字符串，让手机浏览器伪装成桌面浏览器 此外，还有一个已经废除的 navigator.platform 属性，所有浏览器都支持，所以也可以用。它返回一个字符串，表示用户的操作系统。 123if (/Android|iPhone|iPad|iPod/i.test(navigator.platform)) { // 当前设备是移动设备} window.screen，window.innerWidth通过屏幕宽度，判断是否为手机。window.screen 对象返回用户设备的屏幕信息，该对象的 width 属性是屏幕宽度（单位为像素） 123if (window.screen.width &lt; 500) { // 当前设备是移动设备} 缺点：如果手机横屏使用，就识别不了。另一个属性 window.innerWidth 返回浏览器窗口里面的网页可见部分的宽度，比较适合指定网页在不同宽度下的样式 1234567891011const getBrowserWidth = function () { if (window.innerWidth &lt; 768) { return &quot;xs&quot;; } else if (window.innerWidth &lt; 991) { return &quot;sm&quot;; } else if (window.innerWidth &lt; 1199) { return &quot;md&quot;; } else { return &quot;lg&quot;; }}; window.orientation侦测屏幕方向，手机屏幕可以随时改变方向（横屏或竖屏），桌面设备做不到window.orientation 属性用于获取屏幕的当前方向，只有移动设备才有这个属性，桌面设备会返回 undefined 1234// iPhone 的 Safari 浏览器不支持该属性if (typeof window.orientation !== &quot;undefined&quot;) { // 当前设备是移动设备} touch 事件手机浏览器的 DOM 元素可以通过 ontouchstart 属性，为 touch 事件指定监听函数。桌面设备没有这个属性 12345678910111213function isMobile() { return &quot;ontouchstart&quot; in document.documentElement;}// 另一种写法function isMobile() { try { document.createEvent(&quot;TouchEvent&quot;); return true; } catch (e) { return false; }} window.matchMedia()CSS 通过 media query（媒介查询）为网页指定响应式样式。 window.matchMedia() 方法接受一个 CSS 的 media query 语句作为参数，判断这个语句是否生效。 1let isMobile = window.matchMedia(&quot;only screen and (max-width: 760px)&quot;).matches; 除了通过屏幕宽度判断，还可以通过指针的精确性判断。 12// 由于手机不支持鼠标，只支持触摸，所以符合这个条件let isMobile = window.matchMedia(&quot;(pointer:coarse)&quot;).matches; 有些设备支持多种指针，比如同时支持鼠标和触摸。pointer:coarse 只用来判断主指针，此外还有一个 any-pointer 命令判断所有指针 12// any-pointer:coarse表示所有指针里面，只要有一个指针是不精确的，就符合查询条件let isMobile = window.matchMedia(&quot;(any-pointer:coarse)&quot;).matches; 工具 js 侦测推荐 react-device-detect，它支持多种粒度的设备侦测。 12345import { isMobile } from &quot;react-device-detect&quot;;if (isMobile) { // 当前设备是移动设备}","link":"/2021/08/21/%E6%95%99%E7%A8%8B/JavaScript%20%E4%BE%A6%E6%B5%8B%E6%89%8B%E6%9C%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"JavaScript 内存泄漏","text":"什么是内存泄漏?程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak） 所有高级语言都有自己的内存管理系统，而 js 的内存管理也包含在 v8 中。提供自动内存管理，称为”垃圾回收机制” 垃圾回收机制垃圾回收机制怎么知道，哪些内存不再需要呢？ 引用计数：语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是 0，就表示这个值不再用到了，因此可以将这块内存释放 那么，一个值不再需要了，引用数却不为 0，垃圾回收机制无法释放这块内存，从而导致内存泄漏 示例： 1234567// 地址 arr， 地址: 数组值. 此时 数组值的&lt;引用次数&gt;是 1let arr = [1, 2, 3, 4];console.log(&quot;hello world&quot;);// 解除对数组值的引用arr = null;// 或者可以换位其他值, 总之就是不用这个数组了，那声明的数组值会被清理掉arr = undefined; 内存泄漏的识别方法如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用 打开开发者工具，选择 性能（performance） 面板 在顶部的 栏目里面勾选 Memory 点击左上角的录制按钮。 在页面上进行各种操作，模拟用户的使用情况。 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。 结果判定： 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏 如果随着你的操作，内存线不断升高，那么就要小心了 Nodejs 查看当前内存process.memoryUsage() 12345678/** { rss（resident set size）：所有内存占用，包括指令区和堆栈。 heapTotal：&quot;堆&quot;占用的内存，包括用到的和没用到的。 heapUsed：用到的堆的部分。 external： V8 引擎内部的 C++ 对象占用的内存。 } */ 判断内存泄漏，以 heapUsed 字段为准 WeakMap在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。 可以用 WeakSet 和 WeakMap 实现，它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用 如何使用 WeakMap： 1234567const wm = new WeakMap();// 此时 dom 节点的 引用数为 1const element = document.getElementById(&quot;example&quot;);// 此时 dom 节点的引用数仍是 1. 如果是 &lt;Map&gt; 而不是 &lt;WeakMap&gt; 那么 dom 节点的引用数是 2wm.set(element, &quot;some information&quot;);wm.get(element); // &quot;some information&quot;// 浏览器内无法观察到被回收 WeakMap 显示内存示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 首先，打开 Node 命令行。--expose-gc参数表示允许手动执行垃圾回收机制node --expose-gc# 手动执行一次垃圾回收，保证获取的内存使用状态准确&gt; global.gc();undefined# 查看内存占用的初始状态，heapUsed 为 4M 左右&gt; process.memoryUsage();{ rss: 21106688, heapTotal: 7376896, heapUsed: 4339536, external: 9059 }&gt; let wm = new WeakMap();undefined&gt; let b = new Object();undefined&gt; global.gc();undefined# 此时，heapUsed 仍然为 4M 左右&gt; process.memoryUsage();{ rss: 20537344, heapTotal: 9474048, heapUsed: 4620568, external: 8993 }# 在 WeakMap 中添加一个键值对，# 键名为对象 b，键值为一个 5*1024*1024 的数组&gt; wm.set(b, new Array(5*1024*1024));WeakMap {}# 手动执行一次垃圾回收&gt; global.gc();undefined# 此时，heapUsed 为 46M 左右&gt; process.memoryUsage();{ rss: 62652416, heapTotal: 51437568, heapUsed: 46608096, external: 8951 }# 解除对象 b 的引用&gt; b = null;null# 再次执行垃圾回收&gt; global.gc();undefined# 解除 b 的引用以后，heapUsed 变回 4M 左右# 说明 WeakMap 中的那个长度为 5*1024*1024 的数组被销毁了&gt; process.memoryUsage();{ rss: 20639744, heapTotal: 8425472, heapUsed: 4529984, external: 8956 } 上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap 也就是 WeakMap 和 WeakSet 对 引用值有关联性而且 WeakSet 的 value 值，WeakMap 的 key, 只能是对象","link":"/2021/05/17/%E6%95%99%E7%A8%8B/JavaScript%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%95%99%E7%A8%8B/"},{"title":"MIDI Clef 软件 制作8bit曲风","text":"前提 需要配合安卓手机完成 需要用钢琴曲的音乐文件结尾 .mid 或 .midi MP3 在线转 .midi 免费下载 midi 网站 https://bitmidi.com/ 类似网站请自搜 谷歌应用商店下载 MIDI Clef 点击 OpenFile 打开 .mid 文件 点击 01，也就是音轨，钢琴曲不同于我们平时听到的音乐，始终只有一条音轨。此时就相当于给这条音轨加上“滤镜” 点击后，右侧会弹出一个 drawer。下拉到 Synth Lead 的音效选择上。点击 Saw Wave 就会改变音效 还有更多音效待探索。。。 ​","link":"/2022/09/18/%E6%95%99%E7%A8%8B/MIDI%20Clef%20%E8%BD%AF%E4%BB%B6%20%E5%88%B6%E4%BD%9C8bit%E6%9B%B2%E9%A3%8E/"},{"title":"JavaScript 的 this 原理","text":"对 this 的定义this 指的是函数运行时所在的环境 案例解析来看一个经典案例： 123456789101112var obj = { foo: function () { console.log(this.bar); }, bar: 1,};var foo = obj.foo;var bar = 2;obj.foo(); // 1foo(); // 2 我们平时经常用到的： 1234567function name() { console.log(this);}// 由于在最外层调用，一个网页的最外层就是 Window 对象name(); // Window// 由于这里的代码块由 元素#id 所调用，所以这里的this，会输出调用它的domdocument.querySelector(&quot;#id&quot;).onclick = name; js 是如何定义变量的？分两种情况，首先是栈类型var obj = { foo: 5 }; JavaScript 引擎会先在内存里面，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量 obj 也就是说 js 使用了两块内存空间 ‘obj’ 和 ‘{ foo: 5 }’ 那么使用时，想要读取 obj.foo 拿到 5，引擎先从 obj 拿到内存地址，然后再从该地址读出原始的对象，返回它的 foo 属性 12345678{ foo: { [[value]]: 5 [[writable]]: true [[enumerable]]: true [[configurable]]: true }} 堆类型var obj = { foo: function(){} }; 函数单独保存在内存中，然后再将函数的地址赋值给 foo 也就是说 js 使用了三块内存空间 ‘obj’, ‘{ foo }’ 和 function(){} 由于函数是一块单独的空间，所以可以在不同的上下文执行，这也能够解释了上面的案例 call, apply, bind 对 this 的影响都是改变 this 的运行环境. 比如说我们平常用到的一些方法，查找数组中最大值 123456789101112// 用上面的案例举例var obj = { foo: function () { console.log(this); },};obj.foo.call(window); // 本应输出 obj 的函数，改到了 Windowobj.foo.bind(window)(); // Window// 查找数组最大值，这里对 this 没有用到影响，把null换成 window 或 Math 输出也是一样的结果// 因为 apply 把参数转化为了 max 方法可接受的样子 Math.max(1, 2, 3), 这就是 和 call的区别Math.max.apply(null, [1, 2, 3]); ps:只是调用时会改变，不会永久改变 匿名函数只单纯作为函数执行，没有本身的 this, 在 匿名函数中的 this 会向上层作用域查找 👆, 不支持 call, apply, bind 的改变 12345678var obj = { foo: () =&gt; { console.log(this); },};obj.foo(); // Windowobj.foo.call(obj); // Windowobj.foo.call(Array); // Window 总结我们可以简单理解为，谁调用了一块 function，function 中的 this 就指向调用它的对象","link":"/2020/06/07/%E6%95%99%E7%A8%8B/JavaScript%20%E7%9A%84%20this%20%E5%8E%9F%E7%90%86/"},{"title":"Node 调试工具","text":"个人推荐浏览器调试，涉及更全面，主要可查看 内存 和 性能 以下面的代码为例： 12345678const http = require(&quot;http&quot;);const server = http.createServer((req, res) =&gt; { res.end(&quot;hello nodejs&quot;); debugger;});server.listen(6630); 浏览器调试可以直接访问 http://localhost:6630/ 然后点击控制台左上角的 绿色六边形 或输入 chrome://inspect, 看到 Remote Target 里面正在运行的 app.js ，点击链接就会跳转到调试页面 VsCode 调试首先要使用 debug 模式启动服务程序，此时最下面的信息栏颜色会有所变化不能 直接使用 命令行启动。必须通过点击编译器 在执行到断点时， 左侧变量栏会给出调用栈，可以查看执行时的变量信息 更多的调试方法 Chrome 调试 Chrome Dev Tool 博客","link":"/2021/07/09/%E6%95%99%E7%A8%8B/Node%20%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"},{"title":"Shell 命令行动画制作","text":"By Nodejs, 建议，拿对比度高的视频去制作，效果更好 视频转图片 123456789# 安装 ffmpeg （）brew install ffmpeg## 检测是否安装 ffmpegffmpeg -h# ffmpeg -i 视频路径[也可以是绝对路径] -r 帧数 输出图片路径ffmpeg -i ./assets/60f1bcc6321e9fda43c173c84b0391.mp4 -r 15 ./assets/images/%d.png 转化步骤完整源码里已经标注步骤 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const fs = require(&quot;fs&quot;);const { join, extname } = require(&quot;path&quot;);const { read, intToRGBA } = require(&quot;jimp&quot;);const { echo, exit } = require(&quot;shelljs&quot;);const floder = join(__dirname, &quot;./assets/images/&quot;);// 如果画面对比度叫高，推荐使用 const charts = `##### `// 构成字符： 颜色由 深到浅, 也可以增加符号const charts = `@&amp;$%=+!^*~- `;const maxIndex = charts.length - 1;const limitIndex = (num) =&gt; (num &gt; maxIndex ? maxIndex : num);fs.readdir(floder, undefined, (err, data) =&gt; { if (err) throw err; // 6. 过滤非 png 并排序 const files = data.filter((url) =&gt; extname(url) === &quot;.png&quot;); files.sort((a, b) =&gt; parseInt(a) - parseInt(b)); // 7. 递归播放 play(files);});const play = (files) =&gt; { const printFileName = files.shift(); print(printFileName); if (files.length) { setTimeout(() =&gt; { play(files); // ps: 在 js 中 时间函数不可使用 小数 或 负数，否则会立即执行 }, parseInt(1000 / 15)); // 15 取决于 ffmpeg 分割的帧数 return; } exit(1);};const print = (fileName) =&gt; { let subCharts = &quot;&quot;; // 1. 读取图片 const fileURL = join(floder, fileName); read(fileURL).then((image) =&gt; { // 2 获取宽高 ps: 方法不可结构，会报错 const width = image.getWidth(); const height = image.getHeight(); // 6. 调整合适的缩放比例 很重要 const xScale = width / 220; const yScale = height / 40; for (let y = 0; y &lt; height; y += yScale) { for (let x = 0; x &lt; width; x += xScale) { const { r, g, b } = intToRGBA(image.getPixelColor(x, y)); // 3. 读取像素点 的 灰度值 const gray = (0.3 * r + 0.59 * g + 0.11 * b).toFixed(2); // 4. 算出灰度值在 charts 中表达的位置 const grayScale = parseFloat(gray / 255).toFixed(2); const grayDegree = parseInt(grayScale * charts.length); // +0.5 感觉更亮些 const index = Math.floor(limitIndex(grayDegree + 0.5)); // 5. 拼接 subCharts += charts[index]; } subCharts += &quot;\\n&quot;; } echo(subCharts); });}; 素材链接 感谢 大佬 提供 go 版本的教程","link":"/2021/04/25/%E6%95%99%E7%A8%8B/Shell%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C/"},{"title":"Web Components 实例","text":"简介由 4 门技术结合起来的 HTML Imports –&gt; HTML Modules HTML Templates Custom Elements Shadow DOM 成熟的组件库特点： 随处复用 风格统一 动效自然 实例来看一组下面的实例，讲述了如何定义 web components 并获取 iframe 中的 web components 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;开启服务才能获取 iframe 内容&lt;/h1&gt; &lt;iframe src=&quot;./iframe.html&quot;&gt;&lt;/iframe&gt; &lt;fs-components&gt;&lt;/fs-components&gt; &lt;script&gt; customElements.define( &quot;fs-components&quot;, class extends HTMLElement { constructor() { super(); // 相当于 Vue 的 setup console.log(&quot;先运行构造函数&quot;); } connectedCallback() { // 相当于 Vue 的 mounted console.log(&quot;再运行连接回调&quot;); } disconnectedCallback() { // 相当于 Vue 的 unmounted console.log(&quot;当删除组件时才会运行失联回调&quot;); } adoptedCallback() { document.adoptNode(); alert(&quot;被导入&quot;); // document.adoptNode 从外部文档导入节点，剪切式 (有跨域限制🚫) // 当使用 document.adoptNode 后会触发该生命周期 console.log(&quot;当使用 document.adoptNode 后会运行收养回调&quot;); } attributeChangedCallback(name, oldValue, newValue) { // 相当于 Vue 的 watch， 属性变化时回调 } } ); const iframe = document.querySelector(&quot;iframe&quot;); // 对自身网页使用不触发 const selfComponent = document.querySelector(&quot;fs-components&quot;); document.body.appendChild(document.adoptNode(selfComponent)); // 获取iframe中的web-component iframe.onload = () =&gt; { const webComponent = iframe.contentDocument.querySelector(&quot;fancy-components&quot;); document.body.appendChild(document.adoptNode(webComponent)); }; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- iframe.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;If&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;fancy-components&gt;&lt;/fancy-components&gt; &lt;script&gt; customElements.define( &quot;fancy-components&quot;, class extends HTMLElement { constructor() { super(); // 相当于 Vue 的 setup console.log(&quot;先运行构造函数&quot;); } connectedCallback() { // 相当于 Vue 的 mounted console.log(&quot;再运行连接回调&quot;); } disconnectedCallback() { // 相当于 Vue 的 unmounted console.log(&quot;当删除组件时才会运行失联回调&quot;); } adoptedCallback() { alert(&quot;iframe内 fancy-components 被导入&quot;); // document.adoptNode 有跨域限制🚫 // 当使用 document.adoptNode 后会触发该生命周期 console.log(&quot;当使用 document.adoptNode 后会运行收养回调&quot;); } } ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 也可以继承 HTML 元素 12345678910111213customElements.define( &quot;our-input&quot;, class extends HTMLInputElement { constructor() { super(); this.placeholder = &quot;属于我们的输入框！&quot;; this.disabled = true; } // 拓展 HTMLInputElement 的子类 }, { extends: &quot;input&quot; }); 相信从以上案例，已经能初步了解 web components 的用法，更多用途在网络上有更丰富的案例 组件库CSS-Doodle基于 web components 开发的组件库,(炫酷效果的组件库，日常开发中用不到)css-doodle fancy-components花式组件库, 在日常开发中用得到fancy-components 在框架中使用React 支持 WebComponents只要首字母不大写，大写是组件, 小写就是标签 123&lt;fc-button&gt; &lt;TextView /&gt;&lt;/fc-button&gt; Vue 中支持 WebCompents在 vue.config.js 中 12345678910111213141516module.exports = { chainWebpack: (config) =&gt; { config.module .rule(&quot;vue&quot;) .use(&quot;vue-loader&quot;) .tap((options) =&gt; { // 编译忽略某个标签名 options.compilerOptions = { ...(options.compilerOptions || {}), isCustomElement: (tag) =&gt; tag.startsWith(&quot;fc-&quot;), }; return options; }); },}; vite 中使用 WebCompents在 vite.config.js 中 123456789101112// https://vitejs.dev/config/export default defineConfig({ plugins: [ vue({ template: { compilerOptions: { isCustomElement: (tag) =&gt; tag.startsWith(&quot;fc-&quot;), }, }, }), ],});","link":"/2021/06/19/%E6%95%99%E7%A8%8B/Web%20Components%20%E5%AE%9E%E4%BE%8B/"},{"title":"Web Worker 使用","text":"简介Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。 等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢 使用限制 同源限制分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源 DOM 限制Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用 document、window、parent 这些对象。但是，Worker 线程可以 navigator 对象和 location 对象。 通信联系Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成 脚本限制不能执行 alert()方法和 confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求 文件限制Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络. 【本地开发使用 localhost】 使用 API结构： 12345├── index.html├── worker-helper│ ├── 1.js│ └── 2.js└── worker.js 示例： worker 中的全局对象是 DedicatedWorkerGlobalScope，可以当作是 不具有 DOM 对象的 Window 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;file&quot; /&gt; &lt;script&gt; const worker = new Worker(&quot;./worker.js&quot;, { name: &quot;myWorker&quot; }); // 监听worker进程发送的消息 worker.onmessage = function (event) { console.log(&quot;Received message &amp; Work done!&quot; + event.data); // 关闭worker线程 if (event.data === &quot;close&quot;) { worker.terminate(); } }; // 监听错误事件 worker.onerror = function (event) { console.log(`ERROR: Line ${e.lineno} in ${e.filename} : ${e.message}`); }; // worker.postMessage 的参数可以传给 Worker 各种数据类型，包括二进制数据 worker.postMessage(&quot;Hello World&quot;); worker.postMessage({ method: &quot;echo&quot;, args: [&quot;Work&quot;] }); // setTimeout(()=&gt; { // worker.postMessage('close') // }, 3000) console.log(worker); const ab = new ArrayBuffer(100); // postMessage 的 第二个参数是 要转移到 worker 线程的变量 // 被转移的 变量类型是 ArrayBuffer、MessagePort 或 ImageBitmap worker.postMessage(ab, [ab]); // 将变量转移, 第一参数不可以是别的，因为 worker中只能接收第一个参数 console.log(ab); // 此时是 ArrayBuffer(0) 代表已从主线程中去除 worker.addEventListener(&quot;message&quot;, function (event) { if (event.data.byteLength) { console.log(event.data); } }); &lt;/script&gt; &lt;!-- 也可以以标签的形式写web worker --&gt; &lt;script id=&quot;worker&quot; type=&quot;app/worker&quot;&gt; addEventListener('message', function () { postMessage('some message'); }, false); &lt;/script&gt; &lt;script&gt; // 然后再读取。。。 const blob = new Blob([document.querySelector(&quot;#worker&quot;).textContent]); const url = window.URL.createObjectURL(blob); const scriptWorker = new Worker(url); scriptWorker.onmessage = function (e) { // e.data === 'some message' }; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 代码中的 “转移底层” 的概念，也就是 postMessage 的 第二个参数，更多请参考 MDN 文档. SharedArrayBuffer 类型不能被转移，因为已经被共享，SharedArrayBuffer 允许 Worker 线程与主线程共享同一块内存 12345678910111213141516171819202122232425262728293031// worker.jsconsole.log(this); // DedicatedWorkerGlobalScope {}console.log(`worker name: ${this.name}`); // myWorkeraddEventListener( &quot;message&quot;, function (e) { console.log(e); postMessage(`You said: ${e.data}`); // 自身关闭 worker 线程 if (e.data === &quot;close&quot;) { close(); } if (e.data.byteLength) { // 重新移交给主线程 postMessage(e.data, [e.data]); console.log(&quot;worker buffer&quot;, e.data); // 此时的 e.data 是 ArrayBuffer(0) } }, false);// 加载其他脚本importScripts(&quot;./worker-helper/1.js&quot;, &quot;./worker-helper/2.js&quot;);// 监听错误事件addEventListener(&quot;error&quot;, function (e) {});// worker 中也可以再创建 worker// const newWorker = new Worker('./worker-helper/1.js')","link":"/2022/07/23/%E6%95%99%E7%A8%8B/Web%20Worker%20%E4%BD%BF%E7%94%A8/"},{"title":"WebAssembly使用","text":"WebAssembly 的目的是什么？让一些 C 或 C++ 程序，运行在 web 端。例如游戏… 那么首先就需要将 C 或 C++ 代码，转化为 js 代码，然后运行在浏览器里。转化后的这个 js 代码叫做 asm.js, 转化代码的编译器叫做 emscripten 如何使用 emscripten？先去按照步骤下载 emscripten，执行到 source ./emsdk_env.sh 后面，就可以编译 c 程序了。 ps: 每次打开都要在 emsdk 文件夹 执行 source ./emsdk_env.sh 示例： 123456789101112131415161718#include &lt;emscripten.h&gt;#include &lt;iostream&gt;int main() { int val1 = 21; int val2 = EM_ASM_INT({ return $0 * 2; }, val1); std::cout &lt;&lt; &quot;Heallo WebAssembly == &quot; &lt;&lt; val2 &lt;&lt; std::endl;}// hello.cc// 以下是 Emscripten 提供的一些宏// EM_ASM：调用 JS 代码，没有参数，也没有返回值。// EM_ASM_ARGS：调用 JS 代码，可以有任意个参数，但是没有返回值。// EM_ASM_INT：调用 JS 代码，可以有任意个参数，返回一个整数。// EM_ASM_DOUBLE：调用 JS 代码，可以有任意个参数，返回一个双精度浮点数。// EM_ASM_INT_V：调用 JS 代码，没有参数，返回一个整数。// EM_ASM_DOUBLE_V：调用 JS 代码，没有参数，返回一个双精度浮点数。 下面的操作都在 emsdk 文件夹下完成 1234567&gt; source ./emsdk_env.shSetting up EMSDK environment (suppress these messages with EMSDK_QUIET=1)Adding directories to PATH: .......&gt; emcc ～/test/hello.cc -o ～/test/hello.out.js&gt; emcc ～/test/hello.cc -o ～/test/hello.html# -o 控制输出路径 ps: 需要 用 服务来运行 html 文件; npm i serve -g 更多 WebAssembly…https://github.com/mbasso/awesome-wasm","link":"/2022/04/05/%E6%95%99%E7%A8%8B/WebAssembly%E4%BD%BF%E7%94%A8/"},{"title":"js 复刻《仙剑奇侠传》（一）","text":"","link":"/2023/04/10/%E6%95%99%E7%A8%8B/%E4%BB%99%E5%89%91%E5%A5%87%E4%BE%A0%E4%BC%A0(%E4%B8%80)/"},{"title":"大文件上传如何做断点续传 - 前端篇","text":"推荐先去看 后端篇 核心思想 文件分割 分割后并发请求 恢复传输后再将原文件分片，根据当前已发送的分片，跳过 代码实例 启动服务后，需要在不刷新页面的情况下进行。如果需要刷新页面，那需要 IndexedDB 的介入 可以拿 1 ～ 2M 的图片测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js&quot; integrity=&quot;sha512-E8QSvWZ0eCLGk4km3hxSsNmGWbLtSCSUcewDQPQWZF6pEU8GlT8a5fF32wOl1i8ftdMhssTrF/OhyGWwonTcXA==&quot; crossorigin=&quot;anonymous&quot; referrerpolicy=&quot;no-referrer&quot; &gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/axios/1.3.6/axios.min.js&quot; integrity=&quot;sha512-06NZg89vaTNvnFgFTqi/dJKFadQ6FIglD6Yg1HHWAUtVFFoXli9BZL4q4EO1UTKpOfCfW5ws2Z6gw49Swsilsg==&quot; crossorigin=&quot;anonymous&quot; referrerpolicy=&quot;no-referrer&quot; &gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;input type=&quot;file&quot; /&gt; &lt;button onclick=&quot;bf.pause()&quot;&gt;暂停上传&lt;/button &gt;&lt;button onclick=&quot;bf.goOn('487f7b22f68312d2c1bbc93b1aea445b')&quot;&gt; 继续上传 &lt;/button&gt; &lt;p&gt;已经上传 &lt;span&gt;&lt;/span&gt; &lt;span id=&quot;status&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;script&gt; class BigFiles { inputRef = document.querySelector(&quot;input[type=file]&quot;); statusRef = document.querySelector(&quot;#status&quot;); progressRef = document.querySelector(&quot;span&quot;); imgRef = document.querySelector(&quot;img&quot;); source = axios.CancelToken.source(); // 请求队列 queue = []; // 分片大小 (10k) splitSize = 10 * 1024; // 源文件 rawFiles = new Map(); // 已上传的分片 uploaded = {}; constructor() { // 监听上传动作 this.inputRef.addEventListener(&quot;change&quot;, (e) =&gt; { const file = e.target.files[0]; const md5code = CryptoJS.MD5(file).toString(); this.rawFiles.set(md5code, file); this.#_uploadQueue(md5code, file); }); } // 暂停上传 pause = () =&gt; { this.source.cancel(); this.statusRef.innerText = &quot;（已暂停）&quot;; }; // 继续上传 goOn = (md5code) =&gt; { axios({ url: &quot;/check_uploaded&quot;, method: &quot;get&quot;, params: { md5code, }, }).then((res) =&gt; { if (res.data.code !== 200) { return; } const goOnFile = this.rawFiles.get(md5code); if (goOnFile) { // 下面是页面刷新逻辑，如果刷新还需要用IndexedDB,存储文件input选中的文件,和已上传的文件名 if (!this.queue.length) { } // 剔除状态没有完成的请求，再通过 continue push, 保持原分片份数长度，确保进度显示正确 this.queue = this.queue.filter((i) =&gt; i.status === &quot;done&quot;); /* Q: 为什么不取后端存在的文件名？ A: 发起中断的权力在客户端，一旦取消请求，服务端那边写出的二进制文件是未传输完成的，合并出的文件会有问题！ */ this.uploaded[md5code] = doneList.map((d) =&gt; d.filehash); // 最好存入 localStorage 中 // 不能用已取消的 abort 对象，需要重新设置 this.source = axios.CancelToken.source(); this.#_uploadQueue(md5code, goOnFile); this.statusRef.innerText = &quot;&quot;; } }); }; #_uploadQueue = (md5code, file) =&gt; { // file.size的数字是byte就是字节为单位 size: 1 就是 1字节 let cur = 0; // 从0开始 while (cur &lt; file.size) { // 下次分片的开始下表的大小 const nextCur = cur + this.splitSize; // 后端存储的分片名 const filehash = `${md5code}_${nextCur}`; // 如果已上传就跳过 if ( this.uploaded[md5code] &amp;&amp; this.uploaded[md5code].includes(filehash) ) { cur = nextCur; continue; } const formData = new FormData(); // 分割文件，可以把文件的分割，看作数组的分割 formData.append(&quot;file&quot;, file.slice(cur, (cur = nextCur))); formData.append(&quot;hash&quot;, filehash); const item = { status: &quot;&quot;, filehash, request: axios({ url: &quot;/big_files&quot;, method: &quot;post&quot;, data: formData, cancelToken: this.source.token, }).then((e) =&gt; { item.status = &quot;done&quot;; const doneList = this.queue.filter((i) =&gt; i.status === &quot;done&quot;); // 仅做展示用，不需要精确计算 this.progressRef.innerText = `${ parseInt(doneList.length / this.queue.length) * 100 }%`; return e; }), }; // 加入队列 this.queue.push(item); } // 并发队列，只会触发状态为 pending 的 promise Promise.all(this.queue.map((q) =&gt; q.request)).then(() =&gt; this.mergeFiles(md5code) ); }; mergeFiles = (md5code) =&gt; { // 合并文件请求 axios({ url: &quot;/big_files_merge&quot;, method: &quot;post&quot;, data: { hashname: md5code, filename: this.rawFiles.get(md5code).name, }, responseType: &quot;blob&quot;, onDownloadProgress: (progressEvent) =&gt; { const complete = `${ parseInt(progressEvent.loaded / progressEvent.total) * 100 }%`; this.statusRef.innerText = `正在合并图像, 请稍后...(${complete})`; }, }).then((res) =&gt; { // 显示到页面上 const URL = window.URL || window.webkitURL; const href = URL.createObjectURL(res.data); this.imgRef.src = href; this.statusRef.innerText = &quot;&quot;; this.queue = []; }); }; } const bf = new BigFiles(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2020/04/23/%E6%95%99%E7%A8%8B/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A6%82%E4%BD%95%E5%81%9A%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0-%E5%89%8D%E7%AB%AF%E7%AF%87/"},{"title":"大文件上传如何做断点续传 - 后端篇","text":"核心思想 接收前端传输的分片 根据传输的 md5 值来确认是否已上传 如果未上传完成，前端将继续传输分片 合并传输完成的分片 1234567891011# 你的目录工作时，看起来是这样├── imgs│ ├── 487f7b22f68312d2c1bbc93b1aea445b_10240│ ├── 487f7b22f68312d2c1bbc93b1aea445b_20480│ ├── 487f7b22f68312d2c1bbc93b1aea445b_30720│ ├── 487f7b22f68312d2c1bbc93b1aea445b_40960│ ├── 487f7b22f68312d2c1bbc93b1aea445b_51200│ ├── 487f7b22f68312d2c1bbc93b1aea445b_61440│ └── 487f7b22f68312d2c1bbc93b1aea445b_71680├── index.html└── index.js 代码实例下面可直接复制运行, 需要注意地方较多，请仔细阅读在实际应用上，还需改造。。。用到了许多原生 nodejs 方法，其中一些可用 npm 库代替 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150// node -v v18.5.0const http = require(&quot;http&quot;);const fs = require(&quot;fs&quot;);const url = require(&quot;url&quot;);// 存储分片文件夹const tempDir = &quot;./imgs&quot;;// buffer切割方法Buffer.prototype.split = function (sep) { let sepLength = sep.length, arr = [], offset = 0, currentIndex = 0; while ((currentIndex = this.indexOf(sep, offset)) !== -1) { arr.push(this.slice(offset, currentIndex)); offset = currentIndex + sepLength; } arr.push(this.slice(offset)); return arr;};// 解析 formData 方法function handlePart(part) { const [head, body] = part.split(&quot;\\r\\n\\r\\n&quot;); // buffer 分割 const headStr = head.toString(); const key = headStr.match(/name=&quot;(.+?)&quot;/)[1]; const match = headStr.match(/filename=&quot;(.+?)&quot;/); if (!match) { const value = body.toString().slice(0, -2); // 把末尾的 \\r\\n 去掉 return { key, value }; } const filename = match[1]; return { key, value: filename === &quot;blob&quot; ? body : filename };}// 读取文件，写文件const pipeStream = (path, writeStream) =&gt; new Promise((resolve) =&gt; { const readStream = fs.createReadStream(path); readStream.on(&quot;end&quot;, () =&gt; { fs.unlinkSync(path); resolve(); }); readStream.pipe(writeStream); });// 创建http服务const server = http.createServer((req, res) =&gt; { // 处理 url.query const uri = url.parse(req.url, true); // 返回目录下的 index.html if (uri.pathname === &quot;/&quot; &amp;&amp; req.method === &quot;GET&quot;) { res.writeHead(200, { &quot;Content-Type&quot;: &quot;text-plain&quot; }); res.end(fs.readFileSync(&quot;./index.html&quot;)); return; } // 查看是否已经上传 if (uri.pathname === &quot;/check_uploaded&quot; &amp;&amp; req.method === &quot;GET&quot;) { if (!uri.query.md5code) { res.end(&quot;没有md5code&quot;); return; } //TODO: 应该对应 MD5 存入一个 Map 类型的数据在服务中，对应是否 boolean，如果走了 merge，就为true，判断是否上传完成，这里只做粗略判断 const hasSplitFile = fs .readdirSync(tempDir) .some((f) =&gt; f.includes(uri.query.md5code)); res.end( JSON.stringify( hasSplitFile ? { code: 200, data: &quot;还未上传完成&quot; } : { code: 404, data: &quot;该文件已上传完成&quot; } ) ); return; } // 上传/存储分片 if (uri.pathname === &quot;/big_files&quot; &amp;&amp; req.method === &quot;POST&quot;) { let currentBuffer; req.on(&quot;data&quot;, (data) =&gt; { // 如果传输的是 formData 会传输过来 Buffer 类型，传输的 json 就是 字符串 currentBuffer = data; }); req.on(&quot;end&quot;, () =&gt; { // 下面获取formdata value的部分，可以用 multiparty 这个库，这里应用原生方法展示 // 获取 contentType: string const contentType = req.headers[&quot;content-type&quot;]; // 截取 header 里面的 boundary 部分 : --WebKitFormBoundarycBh5zHV8PGTFb5LA const headBoundary = contentType.slice(contentType.lastIndexOf(&quot;=&quot;) + 1); // 前面加两个 - 才是 body 里面真实的分隔符 const bodyBoundary = `--${headBoundary}`; const obj = {}; // 转化formdata 涉及到 buffer 分割 const parts = Buffer.concat([currentBuffer]) .split(bodyBoundary) .slice(1, -1); for (let i = 0; i &lt; parts.length; i++) { // formData key, formData value const { key, value } = handlePart(parts[i]); obj[key] = value; } const exist = fs.existsSync(tempDir); if (!exist) { fs.mkdirSync(tempDir); } // 开始写文件 fs.writeFileSync(`${tempDir}/${obj.hash}`, obj.file); res.end(&quot;ok&quot;); }); return; } // 合并文件 if (uri.pathname === &quot;/big_files_merge&quot; &amp;&amp; req.method === &quot;POST&quot;) { // 每片的大小, 与前端保持一致 const size = 10 * 1024; // @type {filename: string; hashname: string} const postData = {}; req.on(&quot;data&quot;, (data) =&gt; { Object.assign(postData, JSON.parse(data.toString())); }); req.on(&quot;end&quot;, () =&gt; { const files = fs.readdirSync(tempDir); // 排序，必须按顺序读取 const fileGroup = files .filter((filename) =&gt; filename.includes(postData.hashname)) .sort((a, b) =&gt; a.split(`_`)[1] - b.split(`_`)[1]); const streams = fileGroup.map((filename, index) =&gt; pipeStream( `${tempDir}/${filename}`, // 写入同一个文件 fs.createWriteStream(`./${postData.filename}`, { start: index * size, }) ) ); // 并发，读取文件后返回 Promise.all(streams).then(() =&gt; { fs.rmdirSync(tempDir); fs.readFile(postData.filename, (err, buffer) =&gt; { if (err) return; res.end(buffer); }); }); }); return; }});// 启动server.listen(5500);","link":"/2020/04/22/%E6%95%99%E7%A8%8B/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A6%82%E4%BD%95%E5%81%9A%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0-%E5%90%8E%E7%AB%AF%E7%AF%87/"},{"title":"如何用网页脚本追踪用户","text":"点击埋点：当用户点击元素时，收集该点击元素上的信息，并返回给后端 曝光埋点：当需要曝光元素在屏幕 🖥 上出现时，收集该元素上的信息，并返回给后端 数据收集12&lt;button x-click=&quot;message&quot; name=&quot;common&quot;&gt;common button&lt;/button&gt;&lt;div class=&quot;export&quot; export-info=&quot;{}&quot;&gt;&lt;/div&gt; 123456789101112131415161718192021222324const pageClickInfo = {};// 点击埋点window.addEventListener(&quot;click&quot;, (event) =&gt; { // 点击目标元素 const element = event.target; const name = element.getAttribute(&quot;name&quot;); // 信息收集 或 xhr... name &amp;&amp; (pageClickInfo[name] = element.getAttribute(&quot;x-click&quot;));});// 曝光埋点const intersectionObserver = new IntersectionObserver( (entries) =&gt; { entries.forEach((item) =&gt; { console.log(item.target, item.intersectionRatio); // 信息收集 或 xhr... }); }, { threshold: [0.5, 1] });// 为需要曝光的元素添加Array.from(document.getElementsByClassName(&quot;export&quot;)).forEach((el) =&gt; { intersectionObserver.observe(el);}); 数据发送通过 Beacon API需要用到 Beacon API，用于发送不需要响应的 异步，非阻塞请求到服务器。 12345// 通常埋点数据实时发送，unload 方法用于记录用户停留在网页的时间window.addEventListener(&quot;unload&quot;, function (event) { //只能是 POST 请求 @params { url: string, data: ArrayBuffer、ArrayBufferView、Blob、DOMString、FormData 或 URLSearchParams } navigator.sendBeacon(&quot;/log&quot;, &quot;foo=bar&quot;);}); 通过 a 标签的 ping 属性虽然发送的是 POST 请求，但只能发送 query 类型数据，不可指定 body 123&lt;a href=&quot;https://baidu.com&quot; ping=&quot;/log?foo=bar&quot;&gt; click&lt;/a&gt; 反弹追踪就是网页跳转时，先跳到一个或多个中间网址，以便收集信息，然后再跳转到原来的目标网址。防止截取 UA 信息 以确保用户隐私信息，经常会在 【百度搜索】和【洋葱浏览器】上见到 12345678// &lt;a id=&quot;target&quot; href=&quot;https://baidu.com&quot;&gt;click&lt;/a&gt;const link = document.getElementById(&quot;target&quot;);link.addEventListener(&quot;click&quot;, function (event) { event.preventDefault(); const href = link.getAttribute(&quot;href&quot;); window.location.href = `/go?raw_href=${encodeURIComponent(href)}`;});","link":"/2020/02/26/%E6%95%99%E7%A8%8B/%E5%A6%82%E4%BD%95%E7%94%A8%E7%BD%91%E9%A1%B5%E8%84%9A%E6%9C%AC%E8%BF%BD%E8%B8%AA%E7%94%A8%E6%88%B7/"},{"title":"教新手发布土狗币","text":"不论骗子，赌狗，还是投了土狗币相信能暴富的人。本来这篇是想问候各位的家人来着，恶心人来着。但我想一想，哪有比你们更恶心的，光骂你们不够，我要比你们更恶心。归根到底是国内没那么多对区块链，币的认知。现在来教教大家怎么去 发币，添加流动性【变得可交易】, 买卖K线图。你想嗦别人的钱，发币人嗦死你。 发币我们在网上随便找个发币工具 Tokentool 名字留骗子们自己想就行，初始供应量最好上亿，数字不好看可就不好骗了剩下的你就看文档呗, 人家文档都写了 Tokentool 添加流动性就拿Pancake Swap为例, 在币安链上发布的代币，就要在 币安的 swap 上去解决 流动性代币： 你发币代币部署合约的地址 0x... 移除流动性没错，这是跑路的要点，发币人有权把所有代币都拿回来，包括你投里的钱，这就是动动手指的事 🤌Swap 也有文档, 那就不做过多赘述了 买卖 k 线图甭管什么币，你只要添加了流动性，在 AVE 这个里看交易数据就有显示，有新韭菜进来就 涨 📈，老韭菜出去就 跌 📉。所以有些发币人也可以自己做 K 线，多创建几个钱包不就好了 解读 K 线图：小弟不才，如有得罪，那就太好了！就拿 IPFS 来说好了，fil 币只是人家愿意发，跟愿不愿研发 IPFS 没关系。没了 fil， IPFS 照样有 ps: 说明下，fil 币的发行方，已经丢掉了控制权，完全是市场走向 【宣传导致的结果，人心所向的结果】 我就是让更多人知道你们买的是什么，你们听到的是什么。以及如何挥起你们的傻逼小刀，去割贪婪小韭菜","link":"/2023/02/23/%E6%95%99%E7%A8%8B/%E6%96%B0%E6%89%8B%E5%8F%91%E5%B8%83%E5%9C%9F%E7%8B%97%E5%B8%81/"},{"title":"浏览器中的 IndexedDB","text":"作用数据存储在客户端的方法： Cookie：太小 4k Storage：10M 够，但不能搜索和自定义索引 WebSQL：W3C 已不维护，更推荐 IndexDB。 IndexDB：本期主题 简介浏览器提供的本地数据库，可以被网页脚本创建和操作。提供查找接口，还能建立索引。更接近 NoSql IndexedDB 特点 键值对储存。所有类型的数据都可以直接存入，包括 JavaScript 对象。在库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复。 异步。 IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，LocalStorage 的操作是同步的。异步设计是为了防止大量数据的读写，做到了很好的优化。 支持事务。 IndexedDB 支持事务（transaction），只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。 同源限制 IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。 储存空间大 IndexedDB 的储存空间比 LocalStorage 大很多，不少于 250MB，甚至没有上限【不同的浏览器表现不同】。 支持二进制储存。 IndexedDB 不仅可存字符串，还可以存二进制数据（ArrayBuffer 对象和 Blob 对象）。 测试案例下面是一段对 IndexedDB 的简单应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;IndexedDb&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;add()&quot;&gt;添加一条&lt;/button&gt; &lt;button onclick=&quot;getTables()&quot;&gt;获取内容&lt;/button&gt; &lt;button onclick=&quot;upgrade()&quot;&gt;修改一条&lt;/button&gt; &lt;button onclick=&quot;del()&quot;&gt;删除一条&lt;/button&gt; &lt;script&gt; class IndexedDbLib { constructor(dbname, tables, version) { // 版本号只能是正整数，且不可减少，如果版本号增加触发升级事件，如果版本号减少触发error事件 // 创建了数据库对象 this.db = window.indexedDB.open(dbname, version); this.tables = tables; this.#_init(); } #_init() { // bind events --- // 数据库对象的 error 事件 this.db.onerror = (event) =&gt; { console.log(&quot;数据库打开报错&quot;); }; // 数据库对象的 success 事件 this.db.onsuccess = (event) =&gt; { console.log(event.target.result); console.log(&quot;数据库打开成功&quot;); }; // 数据库升级事件，根据版本号变化，没有该数据库时相当于 0 this.db.onupgradeneeded = (event) =&gt; { console.log(&quot;数据库创建/升级&quot;); // 数据库新建成功以后，开始添加表，建表操作只能在 数据库被创建时执行 Object.keys(this.tables).forEach((keyName) =&gt; { let objectStore; if (this.db.result.objectStoreNames.contains(keyName)) { return; } const { keyPath, columns } = this.tables[keyName]; objectStore = this.db.result.createObjectStore(keyName, { keyPath, }); columns.forEach((col) =&gt; { const { key, options } = col; // 键值名 ，索引名， {unique 是否唯一} objectStore.createIndex(key, key, options); }); }); }; } addItems(tables, rowData) { // 创建个事务，模式为 “读写” (可以对多个表发起事务，操作时只能针对事务里的单个表操作) const request = this.db.result.transaction(tables, &quot;readwrite&quot;); // 为两个表都添加 tables.forEach((item) =&gt; { request.objectStore(item).add(rowData); }); request.oncomplete = (event) =&gt; { console.log(&quot;数据写入成功&quot;); }; request.onerror = (event) =&gt; { console.log(&quot;数据写入失败&quot;); }; } deleteItems(table, id) { const request = db .transaction([table], &quot;readwrite&quot;) .objectStore(table) .delete(id); request.onsuccess = (event) =&gt; { console.log(&quot;数据删除成功&quot;); }; } updateItems(table, rowData) { const request = db .transaction([table], &quot;readwrite&quot;) .objectStore(table) .put(rowData); request.onsuccess = (event) =&gt; { console.log(&quot;数据更新成功&quot;); }; request.onerror = (event) =&gt; { console.log(&quot;数据更新失败&quot;); }; } getItems(tables, id) { return new Promise((resolve) =&gt; { const result = {}; // get All if (!id) { const transaction = this.db.result.transaction(tables); tables.forEach((item) =&gt; { const request = transaction.objectStore(item); request.openCursor().onsuccess = (event) =&gt; { const cursor = event.target.result; if (cursor) { console.log(&quot;Id: &quot; + cursor.key); console.log(&quot;Name: &quot; + cursor.value.name); console.log(&quot;Age: &quot; + cursor.value.age); console.log(&quot;Email: &quot; + cursor.value.email); result[item] = result[item] || []; result[item].push(cursor.value); cursor.continue(); } else { console.log(&quot;没有更多数据了！&quot;); if (Object.keys(result).length === tables.length) { resolve(result); } } }; }); return; } // get Item const transaction = this.db.result.transaction(tables); tables.forEach((item) =&gt; { // 获取主键值 const request = transaction.objectStore(item).get(id); request.onerror = (event) =&gt; { console.log(&quot;事务失败&quot;); }; request.onsuccess = (event) =&gt; { if (request.result) { console.log(&quot;Name: &quot; + request.result.name); console.log(&quot;Age: &quot; + request.result.age); console.log(&quot;Email: &quot; + request.result.email); result[item] = request.result; if (Object.keys(result).length === tables.length) { resolve(result); } } else { console.log(&quot;未获得数据记录&quot;); } }; }); }); } } const dbClass = new IndexedDbLib( &quot;dbname&quot;, { person: { keyPath: &quot;id&quot;, columns: [ { key: &quot;email&quot;, options: { unique: false } }, { key: &quot;name&quot;, options: { unique: true } }, { key: &quot;age&quot;, options: { unique: true } }, ], }, testTable: { keyPath: &quot;id&quot;, columns: [ { key: &quot;email&quot;, options: { unique: false } }, { key: &quot;name&quot;, options: { unique: true } }, { key: &quot;age&quot;, options: { unique: true } }, ], }, }, 1 ); const add = () =&gt; { dbClass.addItems([&quot;person&quot;, &quot;testTable&quot;], { id: 2, name: &quot;张三&quot;, age: 24, email: &quot;zhangsan@example.com&quot;, }); }; const getTables = () =&gt; { dbClass.getItems([&quot;person&quot;, &quot;testTable&quot;]).then(console.log); }; const upgrade = () =&gt; { dbClass.updateItems(&quot;person&quot;, { id: 1, name: &quot;李四&quot;, age: 35, email: &quot;lisi@example.com&quot;, }); }; const del = () =&gt; { dbClass.deleteItems(&quot;person&quot;, 1); }; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; IndexedDB 相关的封装库 localForage：一个简单的 Polyfill，提供了简单的客户端数据存储的值语法。它在后台使用 IndexedDB，并在不支持 IndexedDB 的浏览器中回退到 WebSQL 或 localStorage。 Dexie.js：IndexedDB 的包装，通过简单的语法，可以更快地进行代码开发。 ZangoDB：类似 MongoDB 的 IndexedDB 接口，支持 MongoDB 的大多数熟悉的过滤、投影、排序、更新和聚合功能。 JsStore：一个带有 SQL 语法的 IndexedDB 包装器。 MiniMongo：由 localstorage 支持的客户端内存中的 mongodb，通过 http 进行服务器同步。MeteorJS 使用 MiniMongo。 PouchDB：使用 IndexedDB 在浏览器中实现 CouchDB 的客户端。 idb：一个微小的（〜1.15k）库，大多 API 与 IndexedDB 类似，但做了一些小的改进，让数据库的可用性得到了大大的提升。 idb-keyval：使用 IndexedDB 实现的超级简单且小巧的（~600B）基于 Promise 的键值对存储。 sifrr-storage：一个非常小的（~2kB）基于 Promise 的客户端键值数据库。基于 IndexedDB、localStorage、WebSQL 和 Cookies 实现。它可以自动选择上述支持的数据库，并按照优先顺序使用。 lovefield：Lovefield 是一个用于 Web App 的关系型数据库，使用 JavaScript 编写，可以在不同的浏览器环境中运行，提供了类似 SQL 的 API，速度快、安全且易用。","link":"/2019/12/30/%E6%95%99%E7%A8%8B/%E6%B5%8F%E8%A7%88%E5%99%A8%20IndexedDB%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"title":"荒唐的NFT（一） - 上传IPFS图片","text":"准备工作 一个装着 图片的文件夹，里面最好是这种结构 1234├── 1.png├── 2.png├── 3.png#... 写一个 js 文件，生成这种 metadata json 123456789101112131415161718192021222324252627282930{ &quot;name&quot;: &quot;Rabbit #1&quot;, &quot;image&quot;: &quot;ipfs://bafybeibcjaperxogvs4jhi7huxjdkwtjw4hmq7uc5mhk75kokrhbtk3shy/1.png&quot;, &quot;attributes&quot;: [ { &quot;trait_type&quot;: &quot;Background&quot;, &quot;value&quot;: &quot;Orange&quot; }, { &quot;trait_type&quot;: &quot;Scarf&quot;, &quot;value&quot;: &quot;Red&quot; }, { &quot;trait_type&quot;: &quot;Jersey&quot;, &quot;value&quot;: &quot;Argentina&quot; }, { &quot;trait_type&quot;: &quot;Face&quot;, &quot;value&quot;: &quot;White and little pink&quot; }, { &quot;trait_type&quot;: &quot;Eyes&quot;, &quot;value&quot;: &quot;Brown eyes&quot; }, { &quot;trait_type&quot;: &quot;Mouth&quot;, &quot;value&quot;: &quot;Crevice&quot; } ]} 看看分别对应的什么意思，但凡不瞎都应该能看出来… 上传你的答辩图片方式一：下载 ipfs 传输软件 NFT.storage 前提是你的终端可以爬梯子 🪜 方式二： 浏览器必须有梯子 12git clone https://github.com/huasun47/nft.storage-browser-uploader.gitnpm i 上传后的图片地址看起来是这样: ipfs://bafybeibcjaperxogvs4jhi7huxjdkwtjw4hmq7uc5mhk75kokrhbtk3shy/1.png 写入 JS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const { join } = require(&quot;path&quot;);const { writeFile } = require(&quot;fs&quot;);const dir = &quot;./放json的文件夹&quot;;const folder = join(__dirname, dir);let count = 400;const baseURI = &quot;ipfs://地址&quot;;const wirte = () =&gt; { const jsonTxt = `{ &quot;name&quot;: &quot;Rabbit #${count}&quot;, &quot;image&quot;: &quot;${baseURI}${count}.png&quot;, &quot;attributes&quot;: [ { &quot;trait_type&quot;: &quot;Background&quot;, &quot;value&quot;: &quot;Orange&quot; }, { &quot;trait_type&quot;: &quot;Scarf&quot;, &quot;value&quot;: &quot;Red&quot; }, { &quot;trait_type&quot;: &quot;Jersey&quot;, &quot;value&quot;: &quot;Argentina&quot; }, { &quot;trait_type&quot;: &quot;Face&quot;, &quot;value&quot;: &quot;White and little pink&quot; }, { &quot;trait_type&quot;: &quot;Eyes&quot;, &quot;value&quot;: &quot;Brown eyes&quot; }, { &quot;trait_type&quot;: &quot;Mouth&quot;, &quot;value&quot;: &quot;Crevice&quot; } ] }`; const fileName = join(folder, `${count}.json`); writeFile(fileName, jsonTxt, (err) =&gt; { if (err) throw err; count--; if (count &gt; 0) { wirte(); } });};wirte(); 再上传 js 输出的 json 文件是的，你的 NFT，就是串傻逼 JSON 文件 得到 ipfs://bafybeibcjaperxogvs4jhi7huxjdkwtjw4hmq7uc5mhk75kokrhbtk3shy/1.json 类似这种地址","link":"/2023/03/02/%E6%95%99%E7%A8%8B/%E8%8D%92%E5%94%90%E7%9A%84NFT-%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0ipfs%E5%9B%BE%E7%89%87/"},{"title":"荒唐的NFT（二） - Solidity 写合约","text":"代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258// SPDX-License-Identifier: GPL-3.0//Developer : FazelPejmanfar , Twitter :@Pejmanfarfazel/*This a Free Contract, DO NOT SELL IT*/pragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;erc721a/contracts/ERC721A.sol&quot;;import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol&quot;;// 有助于防止对函数的可重入调用import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;// 白名单// import &quot;@openzeppelin/contracts/utils/cryptography/MerkleProof.sol&quot;;import &quot;@openzeppelin/contracts/utils/Strings.sol&quot;;contract WorldCupRabbitNFT is ERC721A, Ownable, ReentrancyGuard { // uint256 类型 可调用 String 的方法 .toString之类的 using Strings for uint256; string public baseURI; string public baseExtension = &quot;.json&quot;; // 未开售图片 // string public notRevealedUri; // 单价 uint256 public cost = 0.041 ether; // 最大供应量 uint256 public maxSupply = 400; // 免费供应量 // uint256 public FreeSupply = 2500; // 最大付费mint // uint256 public MaxperWallet = 10; // 最大免费mint // uint256 public MaxperWalletFree = 3; bool public paused = false; // bool public revealed = false; modifier callerIsUser() { require(tx.origin == msg.sender, &quot;The caller is another contract&quot;); _; } // constructor(string memory _initBaseURI, string memory _notRevealedUri) constructor(string memory _initBaseURI) ERC721A(&quot;WorldCupRabbitNFT&quot;, &quot;Rabbit&quot;) { // change the name and symbol for your collection setBaseURI(_initBaseURI); // setNotRevealedURI(_notRevealedUri); } // internal function _baseURI() internal view virtual override returns (string memory) { return baseURI; } function _startTokenId() internal view virtual override returns (uint256) { return 1; } // public /// @dev Public mint function mint(uint256 tokens) public payable nonReentrant callerIsUser { require(!paused, &quot;oops contract is paused&quot;); // require(tokens &lt;= MaxperWallet, &quot;max mint amount per tx exceeded&quot;); require(totalSupply() + tokens &lt;= maxSupply, &quot;We Soldout&quot;); // require( // _numberMinted(_msgSenderERC721A()) + tokens &lt;= MaxperWallet, // &quot;Max NFT Per Wallet exceeded&quot; // ); require(msg.value &gt;= cost * tokens, &quot;insufficient funds&quot;); _safeMint(_msgSenderERC721A(), tokens); } /// @dev free mint // function freemint(uint256 tokens) public nonReentrant callerIsUser { // require(!paused, &quot;oops contract is paused&quot;); // require(totalSupply() + tokens &lt;= maxSupply, &quot;We Soldout&quot;); // require( // _numberMinted(_msgSenderERC721A()) + tokens &lt;= MaxperWalletFree, // &quot;Max NFT Per Wallet exceeded&quot; // ); // require(tokens &lt;= MaxperWalletFree, &quot;max mint per Tx exceeded&quot;); // require( // totalSupply() + tokens &lt;= FreeSupply, // &quot;Whitelist MaxSupply exceeded&quot; // ); // _safeMint(_msgSenderERC721A(), tokens); // } /// @dev use it for giveaway and team mint // function airdrop(uint256 _mintAmount, address destination) // public // onlyOwner // nonReentrant // callerIsUser // { // require( // totalSupply() + _mintAmount &lt;= maxSupply, // &quot;max NFT limit exceeded&quot; // ); // _safeMint(destination, _mintAmount); // } /// @notice returns metadata link of tokenid 重写内部 ERC721A 的 tokenURI 方法 function tokenURI(uint256 tokenId) public view virtual override returns (string memory) { require( _exists(tokenId), &quot;ERC721AMetadata: URI query for nonexistent token&quot; ); // if (revealed == false) { // return notRevealedUri; // } string memory currentBaseURI = _baseURI(); return bytes(currentBaseURI).length &gt; 0 ? string( abi.encodePacked( currentBaseURI, tokenId.toString(), baseExtension ) ) : &quot;&quot;; } /// @notice return the number minted by an address // function numberMinted(address owner) public view returns (uint256) { // return _numberMinted(owner); // } /// @notice return the tokens owned by an address // function tokensOfOwner(address owner) // public // view // returns (uint256[] memory) // { // unchecked { // uint256 tokenIdsIdx; // address currOwnershipAddr; // uint256 tokenIdsLength = balanceOf(owner); // uint256[] memory tokenIds = new uint256[](tokenIdsLength); // TokenOwnership memory ownership; // for ( // uint256 i = _startTokenId(); // tokenIdsIdx != tokenIdsLength; // ++i // ) { // ownership = _ownershipAt(i); // if (ownership.burned) { // continue; // } // if (ownership.addr != address(0)) { // currOwnershipAddr = ownership.addr; // } // if (currOwnershipAddr == owner) { // tokenIds[tokenIdsIdx++] = i; // } // } // return tokenIds; // } // } //only owner // function reveal(bool _state) public onlyOwner { // revealed = _state; // } /// @dev change the public max per wallet // function setMaxPerWallet(uint256 _limit) public onlyOwner { // MaxperWallet = _limit; // } /// @dev change the free max per wallet // function setFreeMaxPerWallet(uint256 _limit) public onlyOwner { // MaxperWalletFree = _limit; // } /// @dev change the public price(amount need to be in wei) // function setCost(uint256 _newCost) public onlyOwner { // cost = _newCost; // } /// @dev cut the supply if we dont sold out // function setMaxsupply(uint256 _newsupply) public onlyOwner { // maxSupply = _newsupply; // } /// @dev cut the free supply // function setFreesupply(uint256 _newsupply) public onlyOwner { // FreeSupply = _newsupply; // } /// @dev set base extension(default is .json) // function setBaseExtension(string memory _newBaseExtension) // public // onlyOwner // { // baseExtension = _newBaseExtension; // } /// @dev set hidden uri // function setNotRevealedURI(string memory _notRevealedURI) public onlyOwner { // notRevealedUri = _notRevealedURI; // } // Admin functions ---- function isOwnerCall() public view onlyOwner returns (bool) { unchecked { return owner() == _msgSenderERC721A(); } } /// @dev set your baseuri function setBaseURI(string memory _newBaseURI) public onlyOwner { _checkOwner(); unchecked { baseURI = _newBaseURI; } } function showBalance() external view onlyOwner returns (uint256) { _checkOwner(); unchecked { return address(this).balance; } } /// @dev to pause and unpause your contract(use booleans true or false) function pause(bool _state) external onlyOwner nonReentrant { _checkOwner(); unchecked { paused = _state; } } /// @dev withdraw funds from contract function withdraw() external payable onlyOwner nonReentrant { _checkOwner(); uint256 balance = address(this).balance; payable(owner()).transfer(balance); }} 看看这个 API：modifier callerIsUser: 校验器，是否是用户调用constructor(_initBaseUri): _initBaseUri 初始化时输入上传的答辩 json 的文件夹名_startTokenId：所以叫你从 1.json 开始命名mint: 让你交钱，交易 nft 的方法tokenURI: 就是 json 地址的全路径 readonlyisOwnerCall: 是否是合约部署者调用showBalance: 显示你这个合约里收了多少钱了 ETHpause: 暂停合约 mint 功能withdraw: 取钱跑路 🏃 源码 部署合约去别的地方找教程…","link":"/2023/03/03/%E6%95%99%E7%A8%8B/%E8%8D%92%E5%94%90%E7%9A%84NFT-%E5%90%88%E7%BA%A6%E8%A7%A3%E6%9E%90/"},{"title":"荒唐的NFT（三） - 前端调用合约","text":"预览地址源码地址 核心代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225import { useEffect, useState, useMemo } from &quot;react&quot;;import { useSelector, useDispatch } from &quot;react-redux&quot;;import InputNumber from &quot;rc-input-number&quot;;// 用于选择链接你的钱包，移动H5可用, 增加非钱包打开网页的链接钱包体验import { useConnectModal, useAccount } from &quot;@web3modal/react&quot;;// etherjs.Web3Providerimport { Web3Provider } from &quot;@ethersproject/providers&quot;;// etherjs.Contractimport { Contract } from &quot;@ethersproject/contracts&quot;;// etherjs.Unitsimport { parseEther, formatEther, formatUnits, parseUnits,} from &quot;@ethersproject/units&quot;;import { BigNumber } from &quot;@ethersproject/bignumber&quot;;import { setErrorMsg } from &quot;@/store/modules/app&quot;;// 合约 ABIimport json from &quot;@/assets/WorldCupRabbitNFT.json&quot;;import &quot;animate.css&quot;;import &quot;rc-input-number/assets/index.css&quot;;import type { RootState } from &quot;@/store&quot;;const contract_address: string = process.env.REACT_APP_CONTRACT_ADDRESS || &quot;&quot;;// 获取你metamask中的providerconst provider = window.ethereum ? new Web3Provider(window.ethereum) : undefined;// 链接合约ABIlet contract = new Contract(contract_address, json.abi, provider);// 与合约保持一致const price = 0.041;const max = 400;const successInfo = { msg: &quot;&quot;, hash: &quot;&quot; };const Mint = () =&gt; { const errorMsg = useSelector((state: RootState) =&gt; state.app.errorMsg); const dispatch = useDispatch(); const { open } = useConnectModal(); const { account } = useAccount(); const [paused, setPaused] = useState(false); const [lastCount, setLastCount] = useState(400); const [commonGas, setCommonGas] = useState(&quot;0&quot;); const [count, setCount] = useState(1); const [move, setMove] = useState(false); const [successMsg, setSuccessMsg] = useState({ ...successInfo }); // 获取 与钱包交互的mint信息 const getMintTxParams = async () =&gt; { const data = await contract.populateTransaction.mint(count); // const nonce = await contract.signer.getTransactionCount() return { ...data, // nonce, value: parseEther(totalPrice), }; }; const getCommonGas = async () =&gt; { const params = await getMintTxParams(); try { // 估算gas费 const bigNumberGas = await contract.signer.estimateGas(params); const gas = formatUnits(bigNumberGas, &quot;gwei&quot;); setCommonGas(gas); } catch (err: any) { if (err.reason.includes(&quot;paused&quot;)) { return setPaused(true); } dispatch(setErrorMsg(err.reason)); console.dir(err); } }; // 总价显示 const totalPrice = useMemo(() =&gt; { if (account.isConnected) { setTimeout(() =&gt; { getCommonGas(); }, 100); } const _c = BigNumber.from(count); const _p = parseUnits(`${price}`); return formatEther(_c.mul(_p)); // eslint-disable-next-line react-hooks/exhaustive-deps }, [count, account.isConnected]); // 获取合约中没被mint的nft const getLastCount = async () =&gt; { const bigNum = await contract.totalSupply(); setLastCount(max - bigNum.toNumber()); }; const mint = async () =&gt; { if (!contract.signer) { return open(); } setSuccessMsg({ ...successInfo }); setMove(true); try { // 获取交易参数 const params = await getMintTxParams(); // 唤起 metamask，同意交易则执行 resolve const tx = await contract.signer.sendTransaction(params); // 等待交易完成 const done = await tx.wait(); if (done.transactionHash) { setSuccessMsg({ msg: `Ok! You can see it in your wallet later, or you can check`, hash: done.transactionHash, }); getLastCount(); } setMove(false); } catch (error: any) { const { action, reason } = error; console.dir(error); // JSON.stringify(error) const msg = reason ? `${action}: ${reason}` : &quot;An error has occurred. You need to try resetting your account or re importing&quot;; dispatch(setErrorMsg(msg)); setMove(false); } }; const handleChange = (nextValue: number | null) =&gt; { setCount(nextValue || count); }; useEffect(() =&gt; { if (account.address &amp;&amp; provider) { const signer = provider.getSigner(account.address); contract = contract.connect(signer); getLastCount(); } }, [account.address]); return ( &lt;&gt; &lt;div className=&quot;flex-1 mt-10 sm:mt-32 heng-bg bg-auto sm:bg-contain sm:bg-bottom&quot;&gt; &lt;div className=&quot;text-center m-auto p-8 bg-white shadow-xl rounded-lg w-11/12 sm:w-9/12 relative&quot;&gt; {paused ? ( &lt;&gt;Sorry, We Paused There&lt;/&gt; ) : lastCount === 0 ? ( &lt;&gt;Sorry, We Soldout&lt;/&gt; ) : ( &lt;&gt; &lt;div className=&quot;m-4 p-4 bg-indigo-500 text-white font-bold rounded-lg&quot;&gt; We decided that each wallet can have 10 tokens &lt;/div&gt; &lt;div className=&quot;static sm:absolute connect-font&quot;&gt; You maybe need {totalPrice} + {commonGas} ETH &lt;/div&gt; &lt;div className=&quot;static sm:absolute right-8 font-bold connect-font&quot;&gt; Last {lastCount}/400 &lt;/div&gt; &lt;div className=&quot;p-4 pt-10 mb-4&quot;&gt; &lt;InputNumber className=&quot;!text-lg !h-10&quot; min={1} max={lastCount} precision={0} onChange={handleChange} value={count} /&gt; &lt;/div&gt; &lt;button className={`mint-font text-3xl sm:text-5xl animate__animated ${ move ? &quot;animate__tada&quot; : &quot;&quot; }`} onClick={mint} disabled={move} &gt; Mint {count === 1 ? &quot;A&quot; : count} Rabbit{count === 1 ? &quot;&quot; : &quot;s&quot;}{&quot; &quot;} ! &lt;/button&gt; {!move &amp;&amp; ( &lt;div className=&quot;mt-8&quot;&gt; &lt;span className=&quot;error-font text-xl break-words&quot;&gt; {errorMsg} &lt;/span&gt; &lt;/div&gt; )} {move &amp;&amp; ( &lt;div className=&quot;mt-8&quot;&gt; &lt;span className=&quot;green-font text-xl&quot;&gt; We are mitting, please Wait ... &lt;/span&gt; &lt;/div&gt; )} {successMsg.hash &amp;&amp; ( &lt;div className=&quot;mt-8 break-words&quot;&gt; &lt;span className=&quot;green-font text-xl&quot;&gt; {successMsg.msg} on{&quot; &quot;} &lt;a className=&quot;active-font&quot; href={`https://etherscan.io/tx/${successMsg.hash}`} &gt; etherscan &lt;/a&gt; &lt;/span&gt; &lt;p&gt;{successMsg.hash}&lt;/p&gt; &lt;/div&gt; )} &lt;/&gt; )} &lt;/div&gt; &lt;/div&gt; &lt;/&gt; );};export default Mint;","link":"/2023/03/04/%E6%95%99%E7%A8%8B/%E8%8D%92%E5%94%90%E7%9A%84NFT-%E8%B0%83%E7%94%A8%E5%90%88%E7%BA%A6/"},{"title":"防止网页被嵌入框架的代码","text":"为什么做防嵌入？ 侵犯了作者的著作权，和访问者的知情权； 具有欺骗性极高的特点，利于不法用途； 容易被植入恶意脚本 使用防嵌入代码12345678910try { top.location.hostname; // 判断是否为同域 if (top.location.hostname !== window.location.hostname) { // 不是就让框架地址指向自身 top.location.href = window.location.href; }} catch (e) { top.location.href = window.location.href;}","link":"/2019/11/20/%E6%95%99%E7%A8%8B/%E9%98%B2%E6%AD%A2%E7%BD%91%E9%A1%B5%E8%A2%AB%E5%B5%8C%E5%85%A5%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BB%A3%E7%A0%81/"},{"title":"面试 - Typescript","text":"什么是 TypeScript？ 一种 javascript 的超集，支持高级 js 语法，不能通过浏览器运行，需要编译器编译为 js 为什么用 TypeScript？优势是什么？ 对于开发人员更加友好，支持更高级语法。 主要体现在 更少的出现值的类型错误，IDE 可以自动填充，更加智能 TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？ const 可以用于变量断言，比较方便将值变为只读内容，readonly 用于类型声明，通常用于对象上的某个属性 枚举可支持的比较广泛，可完整支持内外部值计算，编译的结果是一个对象；常量枚举只能用它内部的值计算，编译的值是单个变量。常用的还是 普通枚举 继承方式不同，interface 用 extend 关键字，type 用 &amp;(和号), interface 只能用来描述对象, 而且重名的 interface 会合并，type 不可以重名。type 还可以用于其他类型，如基本类型（原始值）、联合类型、元组。 TypeScript 中 any 类型的作用是什么？ 不清楚类型的一个值，值来源可能是动态的，失去了检查作用 TypeScript 中 any、never、unknown、null &amp; undefined 和 void 有什么区别？ any: 动态的变量类型（失去了类型检查的作用） never: 是 TypeScript 中的底层类型，表示永远不存在的值的类型。例：一个从来不会有返回值的函数 或者 let foo: never; never 类型只能赋值给 never unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型。 null &amp; undefined: 默认情况下 null 和 undefined 是所有类型的子类型, 就是任何值都可以成为 null 或 undefined，但项目中一般开启 ts 开启–strictNullChecks 严格检查都只能赋值给自身类型 void: 没有任何类型。函数没有一个返回值。 undefined 能赋值给 void TypeScript 中 interface 可以给 Function / Array / Class（Indexable）做声明吗？ 可以 TypeScript 中可以使用 String、Number、Boolean、Symbol、Object 等给类型做声明吗？ 可以 TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？ TypeScript：noImplicitThis: true 的情况下，必须去声明 this 的类型，才能在函数或者对象中使用 this。 Typescript 中箭头函数的 this 和 ES6 中箭头函数中的 this 是一致的。 TypeScript 中使用 联合类型访问 时有哪些注意事项？ 当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法 1234567function getLength(something: string | number): number { return something.length;}function getString(something: string | number): string { return something.toString();} TypeScript 如何设计 Class 的声明？ 在声明类的时候，一般类中都会包含，构造函数、对构造函数中的属性进行类型声明、类中的方法。 TypeScript 中如何联合枚举类型的 Key? 123456enum str { A, B, C,}type strUnion = keyof typeof str; // 'A' | 'B' | 'C' keyof 和 typeof 关键字的作用？ keyof 获取类型上的 key 值, 可作用到基础数据类型 typeof 获取一个变量或对象的类型。 123function prop&lt;T extends object, K extends keyof T&gt;(obj: T, key: K) { return obj[key];} TypeScript 中 ?.、??、!、!.、_、** 等符号的含义？ ?. 可选链: 遇到 null 和 undefined 可以立即停止表达式的运行。 ?? 空值合并运算符: 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数。可以把它看作 || ，只是不包含 0 ! 非空断言运算符: x! 将从 x 值域中排除 null 和 undefined。就是将该变量内的 null 和 undefined 剔除，使其可以赋值 例：x!.toFixed(2) 排除了 x 是 null 和 undefined 的情况去使用方法 !. 在变量名后添加，可以断言排除 undefined 和 null 类型 _ 数字分割符： 分隔符不会改变数值字面量的值，使人更容易读懂数字 例：1_101_324 ** 求幂 逻辑运算符: ||= , &amp;&amp;= , ??= 简单介绍一下 TypeScript 模块的加载机制？ 首先，编译器会尝试定位需要导入的模块文件，通过绝对或者相对的路径查找方式 如果没有查找到对应的模块，编译器会尝试定位一个外部模块声明（.d.ts） 如果还没找到就报错 TypeScript 中对象展开会有什么副作用吗？ 展开对象后面的属性会覆盖前面的属性； 仅包含对象自身的可枚举属性，不可枚举的属性将会丢失。 类型的全局声明和局部声明? 查看文件是否包含 import、export，不包含就是全局声明 TypeScript 中同名的 interface 或者同名的 interface 和 class 可以合并吗？ 同名的 interface 会自动合并，class 会自动使用同名的 interface 如何使 TypeScript 项目引入并识别编译为 JavaScript 的 npm 库包？ 选择安装 ts 版本，npm install @types/包名 –save； 对于没有类型的 js 库，需要编写同名的.d.ts 文件 TypeScript 的 tsconfig.json 中有哪些配置项信息？ files 是一个数组列表，用来指定待编译文件，在编译的时候只会编译包含在 files 中列出的文件。、 include &amp; exclude 指定编译某些文件，或者指定排除某些文件。 compileOnSave：true 让 IDE 在保存文件的时候根据 tsconfig.json 重新生成文件。 extends 可以通过指定一个其他的 tsconfig.json 文件路径，来继承这个配置文件里的配置。 compilerOptions 编译配置项，如何对具体的 ts 文件进行编译 TypeScript 中如何设置模块导入的路径别名？ 通过 tsconfig.json 中的 compilerOptions.paths 项来配置 declare，declare global 是什么？ declare 是用来定义全局变量、全局函数、全局命名空间、全局模块、class 等 declare global 为全局对象 window 增加新的属性 对 TypeScript 类中成员的 public、private、protected、readonly 修饰符的理解？ public: 成员都默认为 public，被此限定符修饰的成员是可以被外部访问； private: 被此限定符修饰的成员是只可以被类的内部访问； protected: 被此限定符修饰的成员是只可以被类的内部以及类的子类访问; readonly: 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 简述工具类型 Exclude、Omit、Merge、Intersection、Overwrite 的作用。 Exclude&lt;T, U&gt; 从 T 中排除出可分配给 U 的元素。 Omit&lt;T, K&gt; 的作用是忽略 T 中的某些属性。 Merge&lt;O1, O2&gt; 是将两个对象的属性合并。 Compute&lt;A &amp; B&gt; 是将交叉类型合并 Intersection&lt;T, U&gt;的作用是取 T 的属性,此属性同样也存在与 U Overwrite&lt;T, U&gt; 是用 U 的属性覆盖 T 的相同属性。 Patrial&lt; T &gt; 转化为非必选类型。 泛型的使用场景？ 书写上：泛型实际上就是 大写字母开头的 一个 单词或字母，需要写入尖括号内作为一个类型传入 意义上：通常代表一种不确定的类型，可以理解为类型相当于值，传入了 Interface, Class 或 Function 中。经常与 extend 搭配使用，代表某些类型的子类表达与比如 &lt;T extend unknown &gt; 那么 T 就可以是 number, string 或其他可以赋值给 unknown 的类型","link":"/2023/02/07/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%20-%20Typescript/"},{"title":"上古文件 .mkf 读取，理解 Dataview，TypeArray","text":"简介mkf 文件是将图片以二进制存储的一种压缩技术","link":"/2023/05/10/%E6%95%99%E7%A8%8B/%E4%B8%8A%E5%8F%A4%E6%96%87%E4%BB%B6mkf%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"},{"title":"js 复刻《仙剑奇侠传》（前言）","text":"自我问题排除Q: 为什么要做？A: 情怀，单纯想提升自己，还是玩游戏的人舒服 Q: 有什么难度吗？A: 有，对我来说很大，需要去读懂原仙剑一的 C++代码, 并用 JS 复刻出来。我期望并不是用 WASM 转一下就行 Q: 有可以参照的案例吗？A: 只有一个，只不过这位大神在十年前停做了 Sivory/pal.js。 还有一个已经有用 虚幻引擎（UE）复刻的半成品 wrsuperboy/UEPAL，但也属于 C++对本系列无关。全网老子是即将成为的第三个 技术问题排除Q: 为什么不用 Cocos 这种现代引擎做？A: 毕竟做跨语言复刻，一步到位对我存在难度。而且原代码不存在场景，摄像机，纹理的概念。全部是读取 mkf 文件 + 像素偏移，人物默认在中央，绘制在界面上 Q: 转换过程有什么困难的？A: 原仙剑一依赖 SDL2 框架的特性。程序内存在多循环，而做不到唯一主循环，会使我更加难以理解； mkf 文件如何转换为图片并输出到 canvas 上面，mkf 是一种程序的默认压缩文件。压缩体积非常小，是普通 png 图片的1/5 但需要研究如何读取，目前已知需从 ArrayBuffer 转到 UniCode，之后可能会单独出一篇讲 mkf","link":"/2023/04/04/%E6%95%99%E7%A8%8B/%E4%BB%99%E5%89%91%E5%A5%87%E4%BE%A0%E4%BC%A0(%E5%89%8D%E8%A8%80)/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","link":"/tags/Nodejs/"},{"name":"Typescript","slug":"Typescript","link":"/tags/Typescript/"}],"categories":[{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"}],"pages":[]}